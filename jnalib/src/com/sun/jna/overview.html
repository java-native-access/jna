<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
<!-- 
  Copyright 2007 Timothy Wall
-->
</head>

<HR>
<CENTER>
<H1>Java Native Access</H1>
</CENTER>
<body bgcolor="white">
This document is the API specification for the
<a href=http://jna.dev.java.net>JNA</a>
library for simplified native library access for Java.
<p>
<a href=#navbar_top>Top</a>&nbsp;
<a href=http://jna.dev.java.net>JNA Home</a>&nbsp;
<a href=index.html target=_top>API w/FRAMES</a>&nbsp;
<p>

<h1>Java Native Access (JNA)</h1>
JNA provides simplified access to native library methods without requiring any
additional JNI or native code.
<p>

<h2>Library Mapping</h2>
When you've determined which shared library holds the methods to which you
need access, create an interface class corresponding to that library.  For
example, a mapping for the C library itself would look like this:<br>
<code><pre>
public interface CLibrary extends Library {
    CLibrary INSTANCE = (CLibrary)Native.loadLibrary("c", CLibrary.class);
}
</pre></code>
The <code>String</code> passed to the <code>Native.loadLibrary</code> method
is the undecorated name of the shared library file.  Here are some examples of
library name mappings.  
<table>
<tr><td><b>OS</b></td><td><b>Library Name</b></td><td><b>String</b></td></tr>
<tr><td>Windows</td><td>user32.dll</td><td>user32</td></tr>
<tr><td>Linux</td><td>libX11.so</td><td>X11</td></tr>
<tr><td>Mac OS X</td><td>libm.dylib</td><td>m</td></tr>
</table>
<p>
Any given native library with a unique filesystem path is represented by a single instance of {@link com.sun.jna.NativeLibrary} and obtained via {@link com.sun.jna.NativeLibrary#getInstance(String)}.  The native library will be unloaded when no longer referenced by any Java code.

<h2>Function Mapping</h2>
Function names are mapped directly from their Java interface name to the
symbol exported by the native library.  For instance, the function to convert
an ASCII string into an integer would look like this:<br>
<code><pre>
public interface CLibrary extends Library {
    int atol(String s);
}
</pre></code>
If you prefer to rename the Java methods to conform to Java coding
conventions, then you can provide a <code>Map</code> to
<code>Native.loadLibrary</code> which maps the Java names to the native
names.  While this keeps your Java code a little cleaner, the additional
mapping of names may make a little less obvious the native functions being called.<p>
An instance of the {@link com.sun.jna.Function} class is obtained through the {@link com.sun.jna.NativeLibrary} instance corresponding to the containing native library.  This {@link com.sun.jna.Function} instance handles argument marshalling and delegation to the native function. 

<h2>Function Argument Mapping (Java to Native Type Conversions, or Marshalling/Unmarshalling)</h2>
Java types are chosen to match native types of the same size.  These are the
default type mappings:<br>
<table>
<tr><td><b>Native Type</b></td><td><b>Java Type</b></td></tr>
<tr><td>int (boolean)</td><td><i>boolean</i> (mapping can be customized)</td>
<tr><td>char</td><td><b>byte</b></td>
<tr><td>char*</td><td><i>String</i></td>
<tr><td>wchar_t</td><td><b>char</b></td>
<tr><td>wchar_t*</td><td><i>{@link com.sun.jna.WString}</i></td>
<tr><td>short</td><td><b>short</b></td>
<tr><td>long</td><td><b>int</b></td>
<tr><td>long long</td><td><b>long</b></td>
<tr><td>float</td><td><b>float</b></td>
<tr><td>double</td><td><b>double</b></td>
<tr><td>pointer (array of type as pointer)</td><td><b><i>&lt;T&gt;[]</i> or <i>{@link java.nio.ByteBuffer}</i></b></td>
<tr><td>pointer (to type)</td><td><i>{@link com.sun.jna.ptr.ByReference}</i></td>
<tr><td>struct* (pointer to struct)</td><td><i>{@link com.sun.jna.Structure}</i></td>
<tr><td>struct[] (array of contiguous structs)</td><td><i>{@link com.sun.jna.Structure}[]</i></td>
<tr><td>arrays within a struct</td><td>Array of (primitive) type</td>
<tr><td>struct within a struct</td><td>{@link com.sun.jna.Structure}</td>
<tr><td><i>not yet implemented</i></td>
<tr><td>unions</td>
<tr><td>bitfields</td>
</table>
<p>
Only the Java types indicated in bold are handled directly in native code.
All other types must eventually be converted to one of these basic types.
Those Java types in italics are handled by the JNA Java library and converted
to or from one of the basic types.
<p>
Type mapping behavior may be customized by providing a {@link com.sun.jna.TypeMapper} for the {@link com.sun.jna.Library#OPTION_TYPE_MAPPER} option when initializing a library interface.  See {@link com.sun.jna.win32.W32APITypeMapper} for an example which provides custom conversion of boolean and String types.  You are free to use whatever types are convenient in your defined interfaces, but all custom types <em>must</em> provide a mapping to one of the basic or derived types listed above.
<p>

<h3>Pointers</h3>
Pointers may be used as an opaque type from which other data types may be
extracted.  The user is generally not allowed to construct a Pointer de novo.

<h3>Strings</h3>
Java <code>String</code>s perform the same function as the native types
<code>const char*</code> and <code>const wchar_t*</code>
(<code>NUL</code>-terminated arrays).  In order to use the proper type when
calling a native function, we have to introduce some sort of annotation to
identify how the java  <code>String</code> should be converted.

Java <code>String</code>s are automatically converted to <code>char*</code>
since this is the most common usage of strings.  Strings are automatically
converted to a <code>NUL</code>-terminated array of <code>char</code> across
the function call.  Returned <code>char*</code> values are automatically
copied into a <code>String</code> if the method signature returns
<code>String</code> (<code>strdup</code>, for example).
<p>
If the native method returns char* and actually allocates
memory, a return type of {@link com.sun.jna.Pointer} should be used to avoid
leaking the memory.  It is then up to you to take the necessary steps to free
the allocated memory.
<p>

<h3>Wide Strings</h3>
The {@link com.sun.jna.WString} class is used to identify wide character
strings, and only requires a little effort to obtain a
<code>String</code>.  
<p>
While it would be possible to identify wide string arguments by tagging the
strings themselves (for example, with a special prefix like "\u0000W\u0000"),
that method can't be used to identify wide string return values.  So for
consistency, the {@link com.sun.jna.WString} type is used in both cases.

<h3>Buffers/Memory Blocks</h3>
Use arrays to represent buffers of primitive types.  A native method cannot
return a Java array, since there is no canonical way to indicate the intended
length of the returned array.  Instead, use one of the array access methods in
the Pointer class, supplying the length of the returned array.<p>
{@link java.nio.ByteBuffer}s may also be used as a memory buffer input
argument; direct byte buffers can often provide much improved performance over
primitive arrays. 

<h3>Structures</h3>

<h4>Pointer-to-Structure Arguments</h4>
To pass a pointer to a structure as an argument, simply use the Java structure
subclass, and a pointer to native data memory will be used.  The contents of
the structure will be passed to the function and updated when the function
returns.  Structures are packed according to the default alignment rules for
the platform's native C <code>struct</code>s.  

<h4>Array-of-Structure Arguments</h4>
To pass an array of structures, simply use a Java array of the desired
structure type.  If the array is uninitialized, it will be auto-initialized
prior to the function call.<p>
<code><pre>
// C code
void get_devices(struct Device[], int size);

// Java
int size = ...
Device[] devices = new Device[size];
lib.get_devices(devices, devices.length);
</pre></code>

<h4>Array of <code>struct</code>s Returned</h4>
Declare the method as returning a {@link com.sun.jna.Structure} of the
appropriate type, then invoke {@link com.sun.jna.Structure#toArray(int)} to
convert to an array of initialized structures of the appropriate size.  Note
that your {@link com.sun.jna.Structure} class must have a no-args constructor,
and you are responsible for freeing the returned memory if applicable in
whatever way is appropriate for the called function.<p>
<code><pre>
// C code
struct Display* get_displays(int* pcount);
void free_displays(struct Display* displays);

// Java
Display get_displays(InteByReference pcount);
void free_displays(Display[] displays);
...
IntByReference pcount = new IntByReference();
Display d = lib.get_displays(pcount);
Display[] displays = (Display[])d.toArray(new Display[pcount.getValue()]);
...
lib.free_displays(displays);
</pre></code>

<h4>Nested Structure Definitions</h4>
Nested structures are treated as consecutive memory (as opposed to pointers to
structures).  For example:<br>
<code><pre>
// C code
typedef struct _Point {
  int x, y;
} Point;

typedef struct _Line {
  Point start;
  Point end;
} Line;

// JNA code
class Point extends Structure {
  public int x, y;
}

class Line extends Structure {
  public Point start;
  public Point end;
}
</pre></code>

Explicit initialization of nested structures is not required; the objects will
be created as needed and properly mapped to the parent structure's memory.<p>

If you need a pointer to a structure, do this instead:<br>

<code><pre>
// C code
typedef struct _Line2 {
  Point* p1;
  Point* p2;
} Line2;

// JNA code
class Line2 extends Structure {
  public Pointer p1;
  public Pointer p2;
}

Line2 line2;
Point p1, p2;
...
line2.p1 = p1.getPointer();
line2.p2 = p2.getPointer();
</pre></code>

<h4>Nested arrays</h4>
Structures with nested arrays require an explicit constructor to ensure the
structure size is properly calculated.
<code><pre>
typedef struct _Buffer {
  char buf1[32];
  char buf2[1024];
} Buffer;

class Buffer extends Structure {
  public byte[] buf1 = new byte[32];
  public byte[] buf2 = new byte[1024];
}
</pre></code>

Calculation of the native size of the structure is deferred until the
structure is actually used.

<h4>Variable-sized structures</h4>
Structures with variable size, for example:<br>
<code><pre>
// C code
typedef struct _Header {
  int flags;
  int buf_length;
  char buffer[1];
} Header;
</pre></code>

require a constructor which establishes the required size for the structure
and initializes things appropriately.  For example:<br>

<code><pre>
// JNA code
class Header extends Structure {
  public int flags;
  public int buf_length;
  public byte[] buffer;
  public Header(int bufferSize) {
    buffer = new byte[bufferSize];
    buf_length = buffer.length;
    allocateMemory();
  }
}
</pre></code>

<h3>Java Object arguments</h3>
In some cases, it would seem convenient to pass a Java object as an opaque
pointer for later use by a Java callback method.  Unfortunately, this proves
problematic in that the native code must become responsible for reference
tracking.   Until a consistent method or methods of handling these situations
is formulated, passing Java objects directly is not supported.

</body>
</html>
